{"meta":{"title":"2rever的前端小站","subtitle":null,"description":null,"author":"2rever","url":"https://2rever.cn"},"pages":[],"posts":[{"title":"数组的结构赋值","slug":"数组的结构赋值","date":"2018-11-20T15:18:08.000Z","updated":"2018-11-20T15:19:26.076Z","comments":true,"path":"2018/11/20/数组的结构赋值/","link":"","permalink":"https://2rever.cn/2018/11/20/数组的结构赋值/","excerpt":"","text":"数组的结构赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 1. 数组对应的解构赋值let a = 1, b = 2 , c = 3;console.log('a :', a);console.log('b :', b);console.log('c :', c);let a = 1;let b = 2;let c = 3;console.log('a :', a);console.log('b :', b);console.log('c :', c);// 声明三个变量let [a, b, c] = [1, 233, 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 2. 复杂的解构赋值let [ a, [b], c] = [1, [2], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 3. 越过解析let [a, ,b] = [1, 2, 3];console.log('a :', a);console.log('b :', b);// 4. 配合展开运算符let [a, [b, ...d], c] = [1, [2, 3, 4], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);console.log('d :', d);// 5. 如果解构不成功，变量的值就等于undefined。let [a, b] = [1];console.log('a :', a);console.log('b :', b);// a : 1// b : undefined// 6. 不完全解构let [ a, [b], c] = [1, [2, 3, 4], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 7. 数组的解构赋值：如果等号的右边不是数组，那么将会报错。let [a, b] = null;let [a, b] = undefined;let [a, b] = &#123;&#125;;let [a, b] = 123;// 8. 解构赋值允许指定默认值。let [a = 9, b = 0, c = 3] = [ 1, 2];console.log('a :', a);console.log('b :', b);console.log('c :', c);let [a = 2, b = 9] = [undefined, 2]console.log('a :', a);console.log('b :', b);// 9. 当一个数组成员严格等于undefined，默认值才会生效。// 10. 默认值可以引用解构赋值的其他变量，但该变量必须已经声明let [a = 9, b = a] = [1];console.log('a :', a);console.log('b :', b);","categories":[],"tags":[]},{"title":"let以及const笔记","slug":"let以及const笔记","date":"2018-11-20T15:17:39.000Z","updated":"2018-11-20T15:17:57.063Z","comments":true,"path":"2018/11/20/let以及const笔记/","link":"","permalink":"https://2rever.cn/2018/11/20/let以及const笔记/","excerpt":"","text":"let 及 const let 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// &#123;// var a = 10;// console.log(a); //=&gt; 10// &#125;// console.log(a); // a =&gt; 10// 变量提升和函数提升fun();function fun() &#123; console.log(a); var a = 99; console.log(a);&#125;// let 和const// 1. let：变量，有块级的作用域&#123; let b = 100; console.log(b); // b =&gt; 100&#125;console.log(b); // 报错// 2. let 声明变量，没有变量提升。而且有暂时性死区&#123; console.log(b); // ReferenceError: b is not defined let b = 'aicoder.com'; console.log(b);&#125;// 3. 配合for循环可以解决我之前的for(var i = 0; i &lt; 10; i++) &#123; setTimeout(()=&gt;&#123; console.log(i); &#125;, 4);&#125;// 闭包解决方法for(var i = 0; i &lt; 10; i++) &#123; (function(index) &#123; setTimeout(()=&gt;&#123; console.log(index); &#125;, 4); &#125;)(i)&#125;// 用let声明的方法，解决循环索引的问题for(let i = 0; i &lt; 10; i++) &#123; // let i = 0 setTimeout(()=&gt;&#123; console.log(i); &#125;, 4);&#125;// 4. let不能重复声明变量let a = 10;let a = \"aicoder.com\"; // SyntaxError: Identifier 'a' has already been declared// 5. let声明的变量不会添加到 全局对象上去。var a = 10;console.log(window.a);let b = 11;console.log(window.b); const 123456789101112131415161718192021222324252627282930313233// 1. const 声明后，需要立即赋值。后续不能修改const a = 10;a = 19; // TypeError: Assignment to constant variable.const b ; // SyntaxError: Missing initializer in const declarationb = 199; // 2. const 声明的变量，也是有暂时性死区&#123; console.log(a); // ReferenceError: a is not defined const a = 'aicoder.com'; console.log(a);&#125;// 3. const 与复杂类型const stu = &#123;&#125;; // 要求指向的 具体的内存地址不能修改。stu.age = 20;console.log(stu);// 4. const 类型声明的变量也不属于全局对象属性const k = 'aicoder.com';console.log(window.k);// 5. const 不允许进行重复声明// 最新权限原则。","categories":[],"tags":[]},{"title":"健身计划","slug":"健身计划","date":"2018-11-05T15:01:29.000Z","updated":"2018-11-05T15:01:51.484Z","comments":true,"path":"2018/11/05/健身计划/","link":"","permalink":"https://2rever.cn/2018/11/05/健身计划/","excerpt":"","text":"胸部 动作 数量 注意事项 上斜板杠铃卧推 5x10 平板杠铃卧推 5x10 上斜板哑铃卧推 4x10 龙门架十字夹胸 5x12 器械夹胸 5x12 哑铃飞鸟 4x12 背部 动作 数量 注意事项 高位下拉 6x10 坐姿划船 6x10 直臂下压 6x12 哑铃划船 5x12 杠铃划船 5x10 可选项，会做就做 肩膀 动作 数量 注意事项 坐姿哑铃推举 5x10 鹿家哑铃飞鸟(平举) 8x15 哑铃后束飞鸟 6x15 哑铃前平举 5x15 胳膊 动作 数量 注意事项 替换为有氧运动，单车或者跑步40min 腿 动作 数量 注意事项 屈腿伸 5x10 杠铃深蹲 5x10 动作要十分小心 腿举 5x10 股二头弯举 6x12","categories":[],"tags":[]},{"title":"js快速排序","slug":"js快速排序","date":"2018-10-23T15:14:36.000Z","updated":"2018-10-23T15:14:09.512Z","comments":true,"path":"2018/10/23/js快速排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js快速排序/","excerpt":"","text":"第二个工业级别的算法 快速排序有就地排序和占用空间的排序 暴力写法（经典写法） 但是这个写法空间占用太大，所以不用这个写法 可以通过快排找到数组中第K大的元素 找到前K大的元素 使用空间最少，速度最快 1234567891011121314151617181920212223function quickSort2(ary) &#123; if (ary.length &lt; 2) &#123; return ary.slice() &#125; var pivot = ary[Math.floor(Math.random() * ary.length)]//0到数组长度的值向下取整为0到数组长度-1 var left = [] var middle = [] var right = [] for(var i = 0; i&lt;ary.length; i++) &#123; var val = ary[i] if (val &lt; pivot) &#123; left.push(val) &#125; if (val === pivot) &#123; middle.push(val) &#125; if (val &gt; pivot) &#123; right.push(val) &#125; &#125; return quickSort(left).concat(middle, quickSort(right))&#125; 高级写法 12345678910111213141516171819202122232425function partition2(ary, start = 0, end = ary.length - 1) &#123; var pivot = ary[start] var i = start var j = end while(i &lt; j) &#123; while(ary[++i] &lt; pivot); while(ary[--j] &gt; pivot); if ()&#123; &#125; swap(ary, i, j) &#125; if()&#123; &#125; swap(ary, i, start) partition2(ary, start, i-1) partition2(ary, i + 1, end)&#125; 最高级写法，面试的时候经常会考到这样的写法，用这种写法满分 火狐浏览器的源码就是这样写的 这是最标准的写法，工业级写法 123456789101112131415161718192021222324252627//comparatop为高级函数，比如案例随机数或者比较函数function partition(ary, comparator, start = 0, end = ary.length - 1, ) &#123; if (start &gt;= end) &#123; //要么是同一个元素，要么是之间没有其他元素了 return &#125; var pivotIndex = Math.floor(Math.random() * (end - start + 1) + start)//这个减法刚好是要求的区间 var pivot = ary[pivotIndex] swap(ary, pivotIndex, end) //换回来 for(var i = start - 1, j = start; j &lt; end; j++) &#123; if (comparator(ary[j], pivot) &lt; 0) &#123; //i+1以前的元素都是小于等于中间数的 i 以后的元素都是大于中间数的 i++ swap(ary, i, j) &#125; &#125; swap(ary, i + 1, end) //把那个随机中间数换回来 partition(ary, comparator, start, i) partition(ary, comparator, i + 2, end) return ary&#125;function quickSort(ary, comparator = (a,b) =&gt; a - b) &#123; return partition(ary, comparator)&#125;","categories":[],"tags":[]},{"title":"js选择排序","slug":"js选择排序","date":"2018-10-23T15:10:36.000Z","updated":"2018-10-23T15:11:09.652Z","comments":true,"path":"2018/10/23/js选择排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js选择排序/","excerpt":"","text":"选择排序 速度较慢，速度为 O(n^2)123456789101112131415//不稳定 n*nfunction selectSort(ary) &#123; var l = ary.length var minPos for(var i = 0; i &lt; l - 1; i++) &#123; minPos = i for(var j = i + 1; j &lt; l; j++) &#123; if (ary[j] &lt; ary[minPos]) &#123; minPos = j &#125; &#125; swap(ary, i, minPos) &#125; return ary&#125;","categories":[],"tags":[]},{"title":"js冒泡排序","slug":"js冒泡排序","date":"2018-10-23T15:09:55.000Z","updated":"2018-10-23T15:10:20.235Z","comments":true,"path":"2018/10/23/js冒泡排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js冒泡排序/","excerpt":"","text":"冒泡排序 速度较慢，速度为 O(n^2) 1234567891011121314151617//冒泡排序//循环控制趟数，i是趟数-1function bubble(array)&#123; for (var i = 0; i &lt; array.length; i++) &#123; //每一趟里面：要对比所有的数据进行交换，把大的值交换到后面的位置 for (var k = 0; k &lt; array.length - i - 1; k++) &#123; //进行判断大小然后交换两个数据 if (array[k]&gt;array[k+1]) &#123; var temp = array[k] array[k] = array[k+1] array[k+1] = temp &#125; &#125; &#125; return array&#125; 冒泡排序 12345678910111213141516171819//稳定 n*nfunction bubbleSort(ary, comparator) &#123; var l = ary.length var swaped for(var i = l - 1; i &gt;= 0; i--) &#123; swaped = false for(var j = 0; j &lt; i; j++) &#123; // if (predicate(ary[j]) &gt; predicate(ary[j + 1])) &#123; if (comparator(ary[j], ary[j+1]) &gt; 0) &#123; swaped = true swap(ary, j, j + 1) &#125; &#125; if (!swaped) &#123; break &#125; &#125; return ary&#125;","categories":[],"tags":[]},{"title":"js归并排序","slug":"js归并排序","date":"2018-10-23T15:09:33.000Z","updated":"2018-10-23T15:09:23.516Z","comments":true,"path":"2018/10/23/js归并排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js归并排序/","excerpt":"","text":"归并排序 第一个工业级别的算法 归并排序没有办法就地排序12345678910111213141516171819202122function mergeSort(ary) &#123; if (ary.length &lt; 2) &#123; return ary.slice() &#125; var mid = Math.floor(ary.length / 2) var left = mergeSort(ary.slice(0, mid)) var right = mergeSort(ary.slice(mid)) var result = [] while(left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; result.push(...left, ...right) return result&#125;","categories":[],"tags":[]},{"title":"bind方法实现（不考虑this）","slug":"js中bind函数的实现（不考虑this）","date":"2018-10-23T14:56:32.000Z","updated":"2018-10-23T14:56:53.157Z","comments":true,"path":"2018/10/23/js中bind函数的实现（不考虑this）/","link":"","permalink":"https://2rever.cn/2018/10/23/js中bind函数的实现（不考虑this）/","excerpt":"","text":"bind函数123456//bind的实现function bind(f,...fixedArgs)&#123; return function(...args)&#123; return f(...fixedArgs,...args) &#125;&#125; 123456789//bind原来的实现function bind(f) &#123; var fixedArgs = Array.from(arguments).slice(1) return function() &#123; var args = Array.from(arguments) var allArgs = fixedArgs.concat(args) return f.apply(null, allArgs) &#125;&#125; 123456789101112131415function bind(fn,thisVal,...fixedArgs)&#123; return function(...args)&#123; var argList = [] var i = 0 fixedArgs.forEach(arg =&gt; &#123; if (arg === window) &#123; argList.push(args[i++]) &#125;else&#123; argList.push(arg) &#125; &#125;) argList.splice(argList.length,0,...args.slice(i)) return fn(...argList) &#125;&#125; 12345function bind(f, thisVal, ...bindedArgs) &#123; return function(...args) &#123; return f.call(thisVal, ...bindedArgs, ...args) &#125;&#125; 1234567891011function bind(f, thisVal) &#123; var bindedArgs = [].slice.call(arguments).slice(2) return function() &#123; if (没被当构造函数调用) &#123; var args = [].slice.call(arguments) return f.apply(thisVal, bindedArgs.concat(args)) &#125; else &#123; return new f(bindedArgs.concat(args)) &#125; &#125;&#125; TODO：由bind返回的函数被当做构造函数调用时，this的绑定会失效。","categories":[],"tags":[]},{"title":"js柯里化curry函数实现","slug":"js柯里化curry函数实现","date":"2018-10-23T14:55:31.000Z","updated":"2018-10-23T14:55:24.660Z","comments":true,"path":"2018/10/23/js柯里化curry函数实现/","link":"","permalink":"https://2rever.cn/2018/10/23/js柯里化curry函数实现/","excerpt":"","text":"curry函数123456789101112131415161718192021222324252627282930313233343536373839404142function curry(f, l = f.length) &#123; return function(...args1) &#123; if (args1.length &gt;= l) &#123; return f(...args1) &#125; else &#123; return function(...args2) &#123; if (args1.length + args2.length &gt;= l) &#123; return f(...args1, ...args2) &#125; else &#123; return function(...args3) &#123; if (args1.length + args2.length + args3.length &gt;= l) &#123; return f(...args1, ...args2, ...args3) else &#123; return function(...args4) &#123; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;function curry(f, l = f.length) &#123; return function(...args) &#123; if (args.length &gt;= l) &#123; return f(...args) &#125; else &#123; return curry(f.bind(null, ...args), l - args.length) &#125; &#125;&#125;function f(a,b,c,d) &#123; return a + b + c + d&#125;ff = curry(f)(1) ()()()()()ff(4) //10ff(5) //11","categories":[],"tags":[]},{"title":"js二叉树遍历方法","slug":"js二叉树遍历方法","date":"2018-10-23T02:32:55.000Z","updated":"2018-10-23T02:40:03.269Z","comments":true,"path":"2018/10/23/js二叉树遍历方法/","link":"","permalink":"https://2rever.cn/2018/10/23/js二叉树遍历方法/","excerpt":"深度优先遍历 二叉树前序遍历 12345678//二叉树前序遍历function preOrderTraverse(root,action = console.log)&#123; if (root) &#123; action(root.val) preOrderTraverse(root.left,action) preOrderTraverse(root.right,action) &#125;&#125; 二叉树后序遍历 12345678//二叉树后序遍历function postOrderTraverse(root,action = console.log)&#123; if (root) &#123; postOrderTraverse(root.left,action) postOrderTraverse(root.right,action) action(root.val) &#125;&#125; 二叉树中序遍历 12345678//二叉树中序遍历function midOrderTraverse(root,action = console.log)&#123; if (root) &#123; midOrderTraverse(root.left,action) action(root.val) midOrderTraverse(root.right,action) &#125;&#125; 广度优先遍历 广度优先遍历是从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。实现：","text":"深度优先遍历 二叉树前序遍历 12345678//二叉树前序遍历function preOrderTraverse(root,action = console.log)&#123; if (root) &#123; action(root.val) preOrderTraverse(root.left,action) preOrderTraverse(root.right,action) &#125;&#125; 二叉树后序遍历 12345678//二叉树后序遍历function postOrderTraverse(root,action = console.log)&#123; if (root) &#123; postOrderTraverse(root.left,action) postOrderTraverse(root.right,action) action(root.val) &#125;&#125; 二叉树中序遍历 12345678//二叉树中序遍历function midOrderTraverse(root,action = console.log)&#123; if (root) &#123; midOrderTraverse(root.left,action) action(root.val) midOrderTraverse(root.right,action) &#125;&#125; 广度优先遍历 广度优先遍历是从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。实现： 使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该结点的左子树为非空，则将该结点的左子树入队列；如果该结点的右子树为非空，则将该结点的右子树入队列。（描述有点不清楚，直接看代码吧。） 1234567891011121314151617181920//按层遍历1 两个数组function levelOrderTraverse(root) &#123; if (!root) &#123; return &#125; var currRow = [root] var nextRow = [] while(currRow.length) &#123; for(var i = 0; i&lt;currRow.length; i++) &#123; console.log(currRow[i].obj) currRow[i].left &amp;&amp; nextRow.push(currRow[i].left) currRow[i].right &amp;&amp; nextRow.push(currRow[i].right) &#125; console.log('--------') currRow = nextRow nextRow = [] &#125; &#125; 12345678910111213141516171819//按层遍历2 一个数组function levelOrderTraverse2(root) &#123; if (!root) &#123; return &#125; var row = [root] while(row.length) &#123; var l = row.length for(var i = 0; i &lt; l; i++) &#123; console.log(row[i].obj) row[i].left &amp;&amp; row.push(row[i].left) row[i].right &amp;&amp; row.push(row[i].right) &#125; row.splice(0, l) console.log('--------') &#125;&#125;","categories":[],"tags":[]},{"title":"node.js自带promisify函数实现","slug":"node.js自带promisify函数实现","date":"2018-10-22T04:49:09.000Z","updated":"2018-10-23T02:38:10.579Z","comments":true,"path":"2018/10/22/node.js自带promisify函数实现/","link":"","permalink":"https://2rever.cn/2018/10/22/node.js自带promisify函数实现/","excerpt":"","text":"123456789101112131415161718192021// 把基于回调的函数转为基于promisefunction promisify(f) &#123; //返回一个函数收集参数 return function(...args) &#123; return new Promise((res,rej) =&gt; &#123; f(...args,(err,data) =&gt; &#123; if(err)&#123; rej(err) &#125;else &#123; res(data) &#125; &#125;) &#125;) &#125;&#125;readFilePromise = promisify(fs.readFile)readFilePromise(&apos;a.txt&apos;).then(content=&gt; &#123; console.log(content)&#125;)","categories":[],"tags":[]},{"title":"二分查找的笔记","slug":"二分查找的笔记","date":"2018-10-12T13:08:42.000Z","updated":"2018-10-23T02:38:11.794Z","comments":true,"path":"2018/10/12/二分查找的笔记/","link":"","permalink":"https://2rever.cn/2018/10/12/二分查找的笔记/","excerpt":"","text":"递归写法 1234567891011121314151617function binarySearch(data, dest, start, end)&#123; var end = end || data.length - 1, start = start || 0, middle = Math.floor((start + end) / 2); // 递归完成条件 if(data[middle] == dest)&#123; return middle; &#125; // 条件判断进行不同的递归 if(dest &lt; data[middle])&#123; return binarySearch(data, dest, 0, middle-1); &#125;else&#123; return binarySearch(data, dest, middle+1, end); &#125; return false;&#125; 非递归写法 1234567891011121314151617function binarySearch(data, dest)&#123; var end = data.length - 1, start = 0; // 只要不符合条件，继续执行循环，直到不满足循环 while(start &lt;= end)&#123; var middle = Math.floor((end + start) / 2); if(data[middle] == dest)&#123; return middle; &#125; if(dest &gt; data[middle])&#123; start = middle + 1; &#125;else&#123; end = middle - 1; &#125; &#125; return false;&#125;","categories":[],"tags":[]},{"title":"react 虚拟DOM和diff算法的笔记","slug":"react 虚拟DOM和diff算法的笔记","date":"2018-10-11T14:57:32.000Z","updated":"2018-10-23T02:38:11.207Z","comments":true,"path":"2018/10/11/react 虚拟DOM和diff算法的笔记/","link":"","permalink":"https://2rever.cn/2018/10/11/react 虚拟DOM和diff算法的笔记/","excerpt":"","text":"几种更改数据算法的区别123456789101112131415161718192021222324252627282930313233343536373839404142431. state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，来显示4. state发生改变5. 数据 + 模板 结合，生成真实的DOM，替换原始DOM* 缺陷： 第一次生成了一个完整的DOM片段 第二次生成了一个完整的DOM片段 第二次的DOM替换第一次的DOM 直接操作DOM元素，消耗大量的性能============================1.state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，并不直接替换原始的DOM4. state 发生改变5. 数据 + 模板 结合，生成真实的DOM，并不直接替换原始DOM6. 新的DOM（DocumentFragment） 和原始的DOM 作比对，找差异7. 找出input 框发生了变化8. 只用新的DOM中的input 元素，替换掉老的DOM的input元素* 缺陷： 性能的提升并不明显，虽然替换input元素节约了一部分性能，但是直接在新旧DOM 做对比，还是有一些性能上的损耗。============================1.state 数据2. JSX 模板3.生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实DOM）(损耗性能)4. 用虚拟DOM的结构，生成真实的DOM，来显示5. state 发生变化6. 数据 + 模板 生成新的虚拟DOM7.比较原始虚拟DOM 和新的虚拟DOM区别，找到两者的区别（极大提升了性能）8.直接操作DOM，改变变化的内容* 优点： 1.性能提升了。 2.它使得跨端应用得以实现 React Native============================ setState优化 setState是异步的，如果连续调用多次setState，react会合并成一次，来节约调用多次setState做的性能消耗。 diff 算法的同层比对 diff算法只比对一层DOM元素，只要一层不一样，则重新生成一次真实DOM，不会继续向下做对比，并替换原来的真实DOM元素，可能会造成DOM重新渲染的浪费，但是因为是同层比对，速度会比较快。而且在虚拟DOM当中设置key值，会对比前后两个虚拟DOM的key值会很快对比出来，当用index来作为key的时候，index是不稳定的，所以尽量不要用index来作为key值，来提升虚拟DOM对比的性能。","categories":[],"tags":[]},{"title":"js里的对象的深浅拷贝","slug":"js深浅拷贝","date":"2018-09-30T06:25:18.000Z","updated":"2018-10-23T02:38:05.827Z","comments":true,"path":"2018/09/30/js深浅拷贝/","link":"","permalink":"https://2rever.cn/2018/09/30/js深浅拷贝/","excerpt":"","text":"众所周知，js里面对象及其数组不是基本数据类型，当复制操作的时候我们不会复制一个值出来，而是复制一个对这个值的指向，当我们有复制对象需求的时候，可以借助lodash上相应的函数，或者使用一下方法实现。 浅拷贝指的是当对象有多层的时候只复制第一层，子对象还是复制的指向。 深拷贝指的是连同子对象都是一个全新的值。 浅拷贝 123456789function shallowCopy(src) &#123; var dst = &#123;&#125; for(var prop in src) &#123; if(src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop] &#125; &#125; return dst&#125; 深拷贝 这种方式是最便捷的深拷贝方式，但是原型链会遭到破坏，原有对象的原型会丢失。 1JSON.parse(JSON.stringify(obj)) 自己实现深拷贝的方式可避免上述的问题 12345678910111213141516171819function deepCopy(src) &#123; // 定义一个对象，用来确定当前的参数是数组还是对象 var objArray = Array.isArray(obj) ? [] : &#123;&#125; // 如果obj存在，且类型为对象 if (obj &amp;&amp; typeof obj === \"object\" ) &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 如果obj的子元素是对象，递归操作 if (obj[key] &amp;&amp; typeof obj[key] === \"object\") &#123; objArray[key] = deepCopy(obj[key]) &#125;else &#123; // 如果不是，直接赋值 objArray[key] = obj[key] &#125; &#125; &#125; &#125; return objArray //返回新的对象&#125;","categories":[],"tags":[]},{"title":"这是我的第一篇文章","slug":"Hexo博客添加评论功能","date":"2018-08-12T04:02:06.000Z","updated":"2018-08-12T04:01:19.228Z","comments":true,"path":"2018/08/12/Hexo博客添加评论功能/","link":"","permalink":"https://2rever.cn/2018/08/12/Hexo博客添加评论功能/","excerpt":"","text":"Hexo博客添加valine评论功能增加评论功能我原来以为添加评论是一件很麻烦的事情，其实就是在LeanCloud上注册账号，获取appId和appKey，然后在themes目录下自己选用的主题目录下，找到_config.yml文件，找到valine字段，把下文xxx字段替换为valine官网上设置里面获取的值填进去就完了，由于本主题已经集成多种非后端评论系统，所以直接开箱即用。12valine_appId: xxxvaline_appKey: xxx","categories":[],"tags":[]}]}