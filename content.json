{"meta":{"title":"2rever的前端小站","subtitle":null,"description":null,"author":"2rever","url":"https://2rever.cn"},"pages":[],"posts":[{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2019-05-08T03:09:22.000Z","updated":"2019-05-08T03:14:49.931Z","comments":true,"path":"2019/05/08/webpack学习笔记/","link":"","permalink":"https://2rever.cn/2019/05/08/webpack学习笔记/","excerpt":"","text":"webpack学习笔记 webpack学习笔记 1234567891011121314151617# 初始化项目npm init# 在项目里安装webpacknpm i webpack webpack-cli -D# 查看webpack 的版本号npm info webpack# 安装特定版本的webpacknpm i webpack@4.16.5 webpack-cli -D# 运行项目内部命令npx webpack -v# 以 webpackconfig.js 这个配置文件为webpack配置文件npx webpack --config webpackconfig.js 新建 webpack.config.js 文件为webpack打包配置文件 配置文件说明 webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const CleanWebpackPlugin = require('clean-webpack-plugin')const webpack = require('webpack')module.exports = &#123; // 如果是development 则不会压缩，如果是production 为压缩的代码 mode: 'development', // 它是一个映射关系，它知道打包出来的文件实际上对应源代码的哪一段 // devtool: 'cheap-module-eval-source-map', // 从哪个文件开始打包，即入口文件 entry: &#123; main: './src/index.js', // entry: './src/index.js' &#125;, devServer:&#123; // 监听服务器的路径 contentBase: './dist', // 监听命令执行打开页面 open: true, // 设置服务器开启端口 port: 8999, // 开启hot module replacement hot: true, // 即使不生效，浏览器也不自动刷新 hotOnly: true // 设置代理 // proxy: &#123; // '/api':'http://localhost:3000' // &#125; &#125; , module: &#123; rules: [&#123; // 字体文件 test: /\\.(eot|ttf|svg)$/, use: &#123; loader: 'file-loader', &#125; &#125;,&#123; test: /\\.(png|jpg|gif)$/, use: &#123; loader: 'url-loader', // 占位符 options: &#123; name: '[name].[ext]', // 打包到文件夹 outputPath: 'images/', // 小于limit大小的字节就转成base64 limit: 2048 &#125;, &#125; &#125;, &#123; test: /\\.less$/, use: ['style-loader', &#123; loader: 'css-loader', options: &#123; // 在@import引用的文件也要走两个loader importLoaders:2, // 模块化打包 modules: true &#125; &#125;, // 安装的时候同时要安装 less less-loader 'less-loader', // 需要配置postcss.config.js文件引入autoprefixer等工具 'postcss-loader'] &#125;] &#125;, // htmlWebpackPlugin会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html当中 plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new CleanWebpackPlugin(), // 使用插件webpack自带HotModuleReplacementPlugin new webpack.HotModuleReplacementPlugin()], // 输出的文件 output: &#123; publicPath: '/', // 打包输出的js的名字 filename: '[name].js', // 打包输出的所在绝对路径 path: path.resolve(__dirname, 'dist') &#125;&#125; 热加载 webpack --watch webpack-dev-serve node server.js 123456789101112131415const express = require('express')const webpack = require('webpack')const webpackMiddleweare = require('webpack-dev-middleware')const config = require('./webpack.config.js')// 编译器，监听改变打包const complier = webpack(config)const app = express()app.use(webpackMiddleweare(complier,&#123; publicPath: config.output.publicPath&#125;))app.listen(3000,() =&gt; &#123; console.log('server is running!!')&#125;) * HMR 代码的时候需要 123456if(module.hot) &#123; module.hot.accept('./number',() =&gt;&#123; document.body.removeChild(document.querySelect('#number')) number() &#125;)&#125; babel 安装 babel-loader新增webpack和babel的通信 安装 @babel/core和@babel/preset-env把es5转换为es6 安装 @babel/polyfill 并 主文件 import &#39;@babel/polyfill&#39; 把没有的函数补充进去，但是会存在主文件打包出来很大，且会污染全局变量 之前用import &#39;@babel/polyfill&#39; 之后用 12 // import \"core-js/stable\"// import \"regenerator-runtime/runtime\" 但是都可以，但是一定要配 corejs:3 12345678910111213141516171819&#123; test: /\\.js$/, // 排除在外的文件 exclude: /node_modules/, // babel-loader只是webpack和babel之间的通信，但是不能把es6代码转换成es5代码 loader: 'babel-loader', options: &#123; // 配置babel使按需加载 presets: [['@babel/preset-env',&#123; // // 目标浏览器是否需要babel转义 // targets: &#123; // chrome: \"67\" // &#125;, // 按需加载的配置,一定要配置corejs:3不然报错 useBuiltIns: 'usage', corejs: 3, &#125;]] &#125; &#125; 如果是打包类库就不能这样配置babel npm i @babel/runtime -S babel-loader里面要配置options 123456\"plugins\": [[\"@babel/plugin-transform-runtime\",&#123; \"corejs\":2, \"helpers\":true, \"regenerator\": true, \"useESModules\": false&#125;]] 如果配置了 corejs:2，需要安装npm i @babel/runtime-corejs2 -S 且不需要在主要的js里面引用 import &#39;@babel/polyfill&#39;等，原来的会污染全局环境，但是这个runtime会以闭包的形式注入js里 如果要配置更多的babel的话，可以新建 .babelrc 把options里面的对象放到 babelrc就可以了 123456789101112&#123; // 配置babel使按需加载 \"presets\": [[\"@babel/preset-env\",&#123; // // 目标浏览器是否需要babel转义 // targets: &#123; // chrome: \"67\" // &#125;, // 按需加载的配置,一定要配置corejs:3不然报错 \"useBuiltIns\": \"usage\", \"corejs\": 3, &#125;]]&#125;","categories":[],"tags":[]},{"title":"xss攻击解释及防御","slug":"xss攻击解释及防御","date":"2019-04-01T14:58:08.000Z","updated":"2019-04-01T15:06:36.303Z","comments":true,"path":"2019/04/01/xss攻击解释及防御/","link":"","permalink":"https://2rever.cn/2019/04/01/xss攻击解释及防御/","excerpt":"","text":"xss攻击 XSS攻击全称跨站脚本攻击 反射型 发出请求时，XSS代码出现在url上，作为输入提交到服务器端，服务器端解析响应后，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 通过诱导链接等手段在url上拼接一段脚本，这段脚本可能是12345678自动执行&lt;img src=\"null\" onerror=\"xxx\" alt=\"\"&gt;触发执行&lt;p onclick=\"xxx\"&gt;&lt;/p&gt;内嵌入广告、攻击页面、csrf引诱页面等&lt;iframe src=\"xxx\" frameborder=\"0\"&gt;&lt;/iframe&gt; 存储型 存储型XSS 和 反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时用再提交XSS代码。 防范XSS的防御措施编码 对用户输入的数据进行HTML Entity编码 过滤 移除用户上传的DOM属性，如onerror等 移除用户上传的Style节点（破坏页面样式），Script节点（权限做任何事情），Iframe（连环触发csrf攻击）节点等 校正 避免直接对HTML Entity解码（不然之前的编码就没用了，在解码过程中也是解析） 使用DOM Parse转换，矫正不配对的DOM标签 Http-only 服务端设置cookie中加入ttp-only请求头，防止js代码获取特定的cookie","categories":[],"tags":[]},{"title":"实现Vue双向绑定","slug":"实现vue双向绑定","date":"2019-03-30T15:51:22.000Z","updated":"2019-03-30T15:53:14.544Z","comments":true,"path":"2019/03/30/实现vue双向绑定/","link":"","permalink":"https://2rever.cn/2019/03/30/实现vue双向绑定/","excerpt":"","text":"Vue双向绑定的实现es5123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; const obj = &#123; value: '' &#125; function onKeyUp(event) &#123; obj.value = event.target.value &#125; // 对 obj.value 进行拦截 Object.defineProperty(obj, 'value', &#123; get: function() &#123; return value &#125;, set: function(newValue) &#123; value = newValue document.querySelector('#value').innerHTML = newValue // 更新视图层 document.querySelector('input').value = newValue // 数据模型改变 &#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 值是：&lt;span id=\"value\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"text\" onkeyup=\"onKeyUp(event)\"&gt;&lt;/body&gt;&lt;/html&gt; es6123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; const obj = &#123;&#125; const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set: function(target, key, value, receiver) &#123; if(key === 'value') &#123; document.querySelector('#value').innerHTML = value document.querySelector('input').value = value &#125; return Reflect.set(target, key, value, receiver) &#125; &#125;) function onKeyUp(event) &#123; newObj.value = event.target.value &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 值是：&lt;span id=\"value\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"text\" onkeyup=\"onKeyUp(event)\"&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"在循环中调用异步函数","slug":"如何在循环中调用异步函数","date":"2019-02-28T11:45:08.000Z","updated":"2019-03-13T11:46:26.514Z","comments":true,"path":"2019/02/28/如何在循环中调用异步函数/","link":"","permalink":"https://2rever.cn/2019/02/28/如何在循环中调用异步函数/","excerpt":"","text":"如何在循环中调用异步函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 预先设定一个数组const arr = [1,2,3,4,5]// forEach是并行执行的，并不会等待await返回的结果，同 Promise.all()// 加不加上 async await 是一样的arr.forEach(async (item) =&gt; &#123; await delay(item)&#125;)// 要执行串行执行的要用for循环来执行，并且使用awaitasync function test &#123; for (var i = 0; i &lt;arr.length; i++) &#123; await delay(item) &#125;&#125;// 异步执行函数function delay(item) &#123; return new Promise((res,rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('开始任务' + item) res(item) console.log('结束任务' + item) &#125;,3000) &#125;).then(res =&gt; console.log('真正完成了任务',item)).catch(err =&gt; console.log('出错了'))&#125;//执行后可以看到返回值是串行执行的test()// 开始任务0// 结束任务0// 真正完成了任务 0// 开始任务1// 结束任务1// 真正完成了任务 1// 开始任务2// 结束任务2// 真正完成了任务 2// 开始任务3// 结束任务3// 真正完成了任务 3// 开始任务4// 结束任务4// 真正完成了任务 4","categories":[],"tags":[]},{"title":"数组对象的排序","slug":"数组对象排序","date":"2018-11-21T15:02:59.000Z","updated":"2018-11-21T15:03:26.843Z","comments":true,"path":"2018/11/21/数组对象排序/","link":"","permalink":"https://2rever.cn/2018/11/21/数组对象排序/","excerpt":"","text":"数组对象的排序因为最近工作遇到要对数组对象进行排序，所以根据冒泡排序进行修改，实现对简单数组对象的排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function sortArray(array, val, order = \"up\") &#123; for (var i = 0; i &lt; array.length; i++) &#123; for (var k = 0; k &lt; array.length - i - 1; k++) &#123; if (array[k][val] &gt; array[k + 1][val]) &#123; var temp = array[k] array[k] = array[k + 1] array[k + 1] = temp &#125; &#125; &#125; return order == \"up\" ? array : sortReverse(array)&#125;function sortReverse(array) &#123; let len = array.length / 2 | 0 let temp for (var i = 0, k = array.length - 1; i &lt; len; i++, k--) &#123; temp = array[i] array[i] = array[k] array[k] = temp &#125; return array&#125;var arr = [&#123; name: 'zopp', age: 79 &#125;, &#123; name: 'gpp', age: 35 &#125;, &#123; name: 'yjj', age: 8 &#125;, &#123; name: 'zopp', age: 48 &#125;, &#123; name: 'gpp', age: 66 &#125;, &#123; name: 'yjj', age: 7 &#125;,];","categories":[],"tags":[]},{"title":"数组的结构赋值","slug":"数组的结构赋值","date":"2018-11-20T15:18:08.000Z","updated":"2018-11-20T15:19:26.076Z","comments":true,"path":"2018/11/20/数组的结构赋值/","link":"","permalink":"https://2rever.cn/2018/11/20/数组的结构赋值/","excerpt":"","text":"数组的结构赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 1. 数组对应的解构赋值let a = 1, b = 2 , c = 3;console.log('a :', a);console.log('b :', b);console.log('c :', c);let a = 1;let b = 2;let c = 3;console.log('a :', a);console.log('b :', b);console.log('c :', c);// 声明三个变量let [a, b, c] = [1, 233, 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 2. 复杂的解构赋值let [ a, [b], c] = [1, [2], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 3. 越过解析let [a, ,b] = [1, 2, 3];console.log('a :', a);console.log('b :', b);// 4. 配合展开运算符let [a, [b, ...d], c] = [1, [2, 3, 4], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);console.log('d :', d);// 5. 如果解构不成功，变量的值就等于undefined。let [a, b] = [1];console.log('a :', a);console.log('b :', b);// a : 1// b : undefined// 6. 不完全解构let [ a, [b], c] = [1, [2, 3, 4], 3];console.log('a :', a);console.log('b :', b);console.log('c :', c);// 7. 数组的解构赋值：如果等号的右边不是数组，那么将会报错。let [a, b] = null;let [a, b] = undefined;let [a, b] = &#123;&#125;;let [a, b] = 123;// 8. 解构赋值允许指定默认值。let [a = 9, b = 0, c = 3] = [ 1, 2];console.log('a :', a);console.log('b :', b);console.log('c :', c);let [a = 2, b = 9] = [undefined, 2]console.log('a :', a);console.log('b :', b);// 9. 当一个数组成员严格等于undefined，默认值才会生效。// 10. 默认值可以引用解构赋值的其他变量，但该变量必须已经声明let [a = 9, b = a] = [1];console.log('a :', a);console.log('b :', b);","categories":[],"tags":[]},{"title":"let以及const笔记","slug":"let以及const笔记","date":"2018-11-20T15:17:39.000Z","updated":"2018-11-20T15:17:57.063Z","comments":true,"path":"2018/11/20/let以及const笔记/","link":"","permalink":"https://2rever.cn/2018/11/20/let以及const笔记/","excerpt":"","text":"let 及 const let 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// &#123;// var a = 10;// console.log(a); //=&gt; 10// &#125;// console.log(a); // a =&gt; 10// 变量提升和函数提升fun();function fun() &#123; console.log(a); var a = 99; console.log(a);&#125;// let 和const// 1. let：变量，有块级的作用域&#123; let b = 100; console.log(b); // b =&gt; 100&#125;console.log(b); // 报错// 2. let 声明变量，没有变量提升。而且有暂时性死区&#123; console.log(b); // ReferenceError: b is not defined let b = 'aicoder.com'; console.log(b);&#125;// 3. 配合for循环可以解决我之前的for(var i = 0; i &lt; 10; i++) &#123; setTimeout(()=&gt;&#123; console.log(i); &#125;, 4);&#125;// 闭包解决方法for(var i = 0; i &lt; 10; i++) &#123; (function(index) &#123; setTimeout(()=&gt;&#123; console.log(index); &#125;, 4); &#125;)(i)&#125;// 用let声明的方法，解决循环索引的问题for(let i = 0; i &lt; 10; i++) &#123; // let i = 0 setTimeout(()=&gt;&#123; console.log(i); &#125;, 4);&#125;// 4. let不能重复声明变量let a = 10;let a = \"aicoder.com\"; // SyntaxError: Identifier 'a' has already been declared// 5. let声明的变量不会添加到 全局对象上去。var a = 10;console.log(window.a);let b = 11;console.log(window.b); const 123456789101112131415161718192021222324252627282930313233// 1. const 声明后，需要立即赋值。后续不能修改const a = 10;a = 19; // TypeError: Assignment to constant variable.const b ; // SyntaxError: Missing initializer in const declarationb = 199; // 2. const 声明的变量，也是有暂时性死区&#123; console.log(a); // ReferenceError: a is not defined const a = 'aicoder.com'; console.log(a);&#125;// 3. const 与复杂类型const stu = &#123;&#125;; // 要求指向的 具体的内存地址不能修改。stu.age = 20;console.log(stu);// 4. const 类型声明的变量也不属于全局对象属性const k = 'aicoder.com';console.log(window.k);// 5. const 不允许进行重复声明// 最新权限原则。","categories":[],"tags":[]},{"title":"健身计划","slug":"健身计划","date":"2018-11-05T15:01:29.000Z","updated":"2018-11-05T15:01:51.484Z","comments":true,"path":"2018/11/05/健身计划/","link":"","permalink":"https://2rever.cn/2018/11/05/健身计划/","excerpt":"","text":"胸部 动作 数量 注意事项 上斜板杠铃卧推 5x10 平板杠铃卧推 5x10 上斜板哑铃卧推 4x10 龙门架十字夹胸 5x12 器械夹胸 5x12 哑铃飞鸟 4x12 背部 动作 数量 注意事项 高位下拉 6x10 坐姿划船 6x10 直臂下压 6x12 哑铃划船 5x12 杠铃划船 5x10 可选项，会做就做 肩膀 动作 数量 注意事项 坐姿哑铃推举 5x10 鹿家哑铃飞鸟(平举) 8x15 哑铃后束飞鸟 6x15 哑铃前平举 5x15 胳膊 动作 数量 注意事项 替换为有氧运动，单车或者跑步40min 腿 动作 数量 注意事项 屈腿伸 5x10 杠铃深蹲 5x10 动作要十分小心 腿举 5x10 股二头弯举 6x12","categories":[],"tags":[]},{"title":"js快速排序","slug":"js快速排序","date":"2018-10-23T15:14:36.000Z","updated":"2018-10-23T15:14:09.512Z","comments":true,"path":"2018/10/23/js快速排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js快速排序/","excerpt":"","text":"第二个工业级别的算法 快速排序有就地排序和占用空间的排序 暴力写法（经典写法） 但是这个写法空间占用太大，所以不用这个写法 可以通过快排找到数组中第K大的元素 找到前K大的元素 使用空间最少，速度最快 1234567891011121314151617181920212223function quickSort2(ary) &#123; if (ary.length &lt; 2) &#123; return ary.slice() &#125; var pivot = ary[Math.floor(Math.random() * ary.length)]//0到数组长度的值向下取整为0到数组长度-1 var left = [] var middle = [] var right = [] for(var i = 0; i&lt;ary.length; i++) &#123; var val = ary[i] if (val &lt; pivot) &#123; left.push(val) &#125; if (val === pivot) &#123; middle.push(val) &#125; if (val &gt; pivot) &#123; right.push(val) &#125; &#125; return quickSort(left).concat(middle, quickSort(right))&#125; 高级写法 12345678910111213141516171819202122232425function partition2(ary, start = 0, end = ary.length - 1) &#123; var pivot = ary[start] var i = start var j = end while(i &lt; j) &#123; while(ary[++i] &lt; pivot); while(ary[--j] &gt; pivot); if ()&#123; &#125; swap(ary, i, j) &#125; if()&#123; &#125; swap(ary, i, start) partition2(ary, start, i-1) partition2(ary, i + 1, end)&#125; 最高级写法，面试的时候经常会考到这样的写法，用这种写法满分 火狐浏览器的源码就是这样写的 这是最标准的写法，工业级写法 123456789101112131415161718192021222324252627//comparatop为高级函数，比如案例随机数或者比较函数function partition(ary, comparator, start = 0, end = ary.length - 1, ) &#123; if (start &gt;= end) &#123; //要么是同一个元素，要么是之间没有其他元素了 return &#125; var pivotIndex = Math.floor(Math.random() * (end - start + 1) + start)//这个减法刚好是要求的区间 var pivot = ary[pivotIndex] swap(ary, pivotIndex, end) //换回来 for(var i = start - 1, j = start; j &lt; end; j++) &#123; if (comparator(ary[j], pivot) &lt; 0) &#123; //i+1以前的元素都是小于等于中间数的 i 以后的元素都是大于中间数的 i++ swap(ary, i, j) &#125; &#125; swap(ary, i + 1, end) //把那个随机中间数换回来 partition(ary, comparator, start, i) partition(ary, comparator, i + 2, end) return ary&#125;function quickSort(ary, comparator = (a,b) =&gt; a - b) &#123; return partition(ary, comparator)&#125;","categories":[],"tags":[]},{"title":"js选择排序","slug":"js选择排序","date":"2018-10-23T15:10:36.000Z","updated":"2018-10-23T15:11:09.652Z","comments":true,"path":"2018/10/23/js选择排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js选择排序/","excerpt":"","text":"选择排序 速度较慢，速度为 O(n^2)123456789101112131415//不稳定 n*nfunction selectSort(ary) &#123; var l = ary.length var minPos for(var i = 0; i &lt; l - 1; i++) &#123; minPos = i for(var j = i + 1; j &lt; l; j++) &#123; if (ary[j] &lt; ary[minPos]) &#123; minPos = j &#125; &#125; swap(ary, i, minPos) &#125; return ary&#125;","categories":[],"tags":[]},{"title":"js冒泡排序","slug":"js冒泡排序","date":"2018-10-23T15:09:55.000Z","updated":"2018-10-23T15:10:20.235Z","comments":true,"path":"2018/10/23/js冒泡排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js冒泡排序/","excerpt":"","text":"冒泡排序 速度较慢，速度为 O(n^2) 1234567891011121314151617//冒泡排序//循环控制趟数，i是趟数-1function bubble(array)&#123; for (var i = 0; i &lt; array.length; i++) &#123; //每一趟里面：要对比所有的数据进行交换，把大的值交换到后面的位置 for (var k = 0; k &lt; array.length - i - 1; k++) &#123; //进行判断大小然后交换两个数据 if (array[k]&gt;array[k+1]) &#123; var temp = array[k] array[k] = array[k+1] array[k+1] = temp &#125; &#125; &#125; return array&#125; 冒泡排序 12345678910111213141516171819//稳定 n*nfunction bubbleSort(ary, comparator) &#123; var l = ary.length var swaped for(var i = l - 1; i &gt;= 0; i--) &#123; swaped = false for(var j = 0; j &lt; i; j++) &#123; // if (predicate(ary[j]) &gt; predicate(ary[j + 1])) &#123; if (comparator(ary[j], ary[j+1]) &gt; 0) &#123; swaped = true swap(ary, j, j + 1) &#125; &#125; if (!swaped) &#123; break &#125; &#125; return ary&#125;","categories":[],"tags":[]},{"title":"js归并排序","slug":"js归并排序","date":"2018-10-23T15:09:33.000Z","updated":"2018-10-23T15:09:23.516Z","comments":true,"path":"2018/10/23/js归并排序/","link":"","permalink":"https://2rever.cn/2018/10/23/js归并排序/","excerpt":"","text":"归并排序 第一个工业级别的算法 归并排序没有办法就地排序12345678910111213141516171819202122function mergeSort(ary) &#123; if (ary.length &lt; 2) &#123; return ary.slice() &#125; var mid = Math.floor(ary.length / 2) var left = mergeSort(ary.slice(0, mid)) var right = mergeSort(ary.slice(mid)) var result = [] while(left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; result.push(...left, ...right) return result&#125;","categories":[],"tags":[]},{"title":"bind方法实现（不考虑this）","slug":"js中bind函数的实现（不考虑this）","date":"2018-10-23T14:56:32.000Z","updated":"2018-10-23T14:56:53.157Z","comments":true,"path":"2018/10/23/js中bind函数的实现（不考虑this）/","link":"","permalink":"https://2rever.cn/2018/10/23/js中bind函数的实现（不考虑this）/","excerpt":"","text":"bind函数123456//bind的实现function bind(f,...fixedArgs)&#123; return function(...args)&#123; return f(...fixedArgs,...args) &#125;&#125; 123456789//bind原来的实现function bind(f) &#123; var fixedArgs = Array.from(arguments).slice(1) return function() &#123; var args = Array.from(arguments) var allArgs = fixedArgs.concat(args) return f.apply(null, allArgs) &#125;&#125; 123456789101112131415function bind(fn,thisVal,...fixedArgs)&#123; return function(...args)&#123; var argList = [] var i = 0 fixedArgs.forEach(arg =&gt; &#123; if (arg === window) &#123; argList.push(args[i++]) &#125;else&#123; argList.push(arg) &#125; &#125;) argList.splice(argList.length,0,...args.slice(i)) return fn(...argList) &#125;&#125; 12345function bind(f, thisVal, ...bindedArgs) &#123; return function(...args) &#123; return f.call(thisVal, ...bindedArgs, ...args) &#125;&#125; 1234567891011function bind(f, thisVal) &#123; var bindedArgs = [].slice.call(arguments).slice(2) return function() &#123; if (没被当构造函数调用) &#123; var args = [].slice.call(arguments) return f.apply(thisVal, bindedArgs.concat(args)) &#125; else &#123; return new f(bindedArgs.concat(args)) &#125; &#125;&#125; TODO：由bind返回的函数被当做构造函数调用时，this的绑定会失效。","categories":[],"tags":[]},{"title":"js柯里化curry函数实现","slug":"js柯里化curry函数实现","date":"2018-10-23T14:55:31.000Z","updated":"2018-10-23T14:55:24.660Z","comments":true,"path":"2018/10/23/js柯里化curry函数实现/","link":"","permalink":"https://2rever.cn/2018/10/23/js柯里化curry函数实现/","excerpt":"","text":"curry函数123456789101112131415161718192021222324252627282930313233343536373839404142function curry(f, l = f.length) &#123; return function(...args1) &#123; if (args1.length &gt;= l) &#123; return f(...args1) &#125; else &#123; return function(...args2) &#123; if (args1.length + args2.length &gt;= l) &#123; return f(...args1, ...args2) &#125; else &#123; return function(...args3) &#123; if (args1.length + args2.length + args3.length &gt;= l) &#123; return f(...args1, ...args2, ...args3) else &#123; return function(...args4) &#123; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;function curry(f, l = f.length) &#123; return function(...args) &#123; if (args.length &gt;= l) &#123; return f(...args) &#125; else &#123; return curry(f.bind(null, ...args), l - args.length) &#125; &#125;&#125;function f(a,b,c,d) &#123; return a + b + c + d&#125;ff = curry(f)(1) ()()()()()ff(4) //10ff(5) //11","categories":[],"tags":[]},{"title":"js二叉树遍历方法","slug":"js二叉树遍历方法","date":"2018-10-23T02:32:55.000Z","updated":"2018-10-23T02:40:03.269Z","comments":true,"path":"2018/10/23/js二叉树遍历方法/","link":"","permalink":"https://2rever.cn/2018/10/23/js二叉树遍历方法/","excerpt":"深度优先遍历 二叉树前序遍历 12345678//二叉树前序遍历function preOrderTraverse(root,action = console.log)&#123; if (root) &#123; action(root.val) preOrderTraverse(root.left,action) preOrderTraverse(root.right,action) &#125;&#125; 二叉树后序遍历 12345678//二叉树后序遍历function postOrderTraverse(root,action = console.log)&#123; if (root) &#123; postOrderTraverse(root.left,action) postOrderTraverse(root.right,action) action(root.val) &#125;&#125; 二叉树中序遍历 12345678//二叉树中序遍历function midOrderTraverse(root,action = console.log)&#123; if (root) &#123; midOrderTraverse(root.left,action) action(root.val) midOrderTraverse(root.right,action) &#125;&#125; 广度优先遍历 广度优先遍历是从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。实现：","text":"深度优先遍历 二叉树前序遍历 12345678//二叉树前序遍历function preOrderTraverse(root,action = console.log)&#123; if (root) &#123; action(root.val) preOrderTraverse(root.left,action) preOrderTraverse(root.right,action) &#125;&#125; 二叉树后序遍历 12345678//二叉树后序遍历function postOrderTraverse(root,action = console.log)&#123; if (root) &#123; postOrderTraverse(root.left,action) postOrderTraverse(root.right,action) action(root.val) &#125;&#125; 二叉树中序遍历 12345678//二叉树中序遍历function midOrderTraverse(root,action = console.log)&#123; if (root) &#123; midOrderTraverse(root.left,action) action(root.val) midOrderTraverse(root.right,action) &#125;&#125; 广度优先遍历 广度优先遍历是从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。实现： 使用数组模拟队列。首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该结点的左子树为非空，则将该结点的左子树入队列；如果该结点的右子树为非空，则将该结点的右子树入队列。（描述有点不清楚，直接看代码吧。） 1234567891011121314151617181920//按层遍历1 两个数组function levelOrderTraverse(root) &#123; if (!root) &#123; return &#125; var currRow = [root] var nextRow = [] while(currRow.length) &#123; for(var i = 0; i&lt;currRow.length; i++) &#123; console.log(currRow[i].obj) currRow[i].left &amp;&amp; nextRow.push(currRow[i].left) currRow[i].right &amp;&amp; nextRow.push(currRow[i].right) &#125; console.log('--------') currRow = nextRow nextRow = [] &#125; &#125; 12345678910111213141516171819//按层遍历2 一个数组function levelOrderTraverse2(root) &#123; if (!root) &#123; return &#125; var row = [root] while(row.length) &#123; var l = row.length for(var i = 0; i &lt; l; i++) &#123; console.log(row[i].obj) row[i].left &amp;&amp; row.push(row[i].left) row[i].right &amp;&amp; row.push(row[i].right) &#125; row.splice(0, l) console.log('--------') &#125;&#125;","categories":[],"tags":[]},{"title":"node.js自带promisify函数实现","slug":"node.js自带promisify函数实现","date":"2018-10-22T04:49:09.000Z","updated":"2018-10-23T02:38:10.579Z","comments":true,"path":"2018/10/22/node.js自带promisify函数实现/","link":"","permalink":"https://2rever.cn/2018/10/22/node.js自带promisify函数实现/","excerpt":"","text":"123456789101112131415161718192021// 把基于回调的函数转为基于promisefunction promisify(f) &#123; //返回一个函数收集参数 return function(...args) &#123; return new Promise((res,rej) =&gt; &#123; f(...args,(err,data) =&gt; &#123; if(err)&#123; rej(err) &#125;else &#123; res(data) &#125; &#125;) &#125;) &#125;&#125;readFilePromise = promisify(fs.readFile)readFilePromise(&apos;a.txt&apos;).then(content=&gt; &#123; console.log(content)&#125;)","categories":[],"tags":[]},{"title":"二分查找的笔记","slug":"二分查找的笔记","date":"2018-10-12T13:08:42.000Z","updated":"2018-10-23T02:38:11.794Z","comments":true,"path":"2018/10/12/二分查找的笔记/","link":"","permalink":"https://2rever.cn/2018/10/12/二分查找的笔记/","excerpt":"","text":"递归写法 1234567891011121314151617function binarySearch(data, dest, start, end)&#123; var end = end || data.length - 1, start = start || 0, middle = Math.floor((start + end) / 2); // 递归完成条件 if(data[middle] == dest)&#123; return middle; &#125; // 条件判断进行不同的递归 if(dest &lt; data[middle])&#123; return binarySearch(data, dest, 0, middle-1); &#125;else&#123; return binarySearch(data, dest, middle+1, end); &#125; return false;&#125; 非递归写法 1234567891011121314151617function binarySearch(data, dest)&#123; var end = data.length - 1, start = 0; // 只要不符合条件，继续执行循环，直到不满足循环 while(start &lt;= end)&#123; var middle = Math.floor((end + start) / 2); if(data[middle] == dest)&#123; return middle; &#125; if(dest &gt; data[middle])&#123; start = middle + 1; &#125;else&#123; end = middle - 1; &#125; &#125; return false;&#125;","categories":[],"tags":[]},{"title":"react 虚拟DOM和diff算法的笔记","slug":"react 虚拟DOM和diff算法的笔记","date":"2018-10-11T14:57:32.000Z","updated":"2018-10-23T02:38:11.207Z","comments":true,"path":"2018/10/11/react 虚拟DOM和diff算法的笔记/","link":"","permalink":"https://2rever.cn/2018/10/11/react 虚拟DOM和diff算法的笔记/","excerpt":"","text":"几种更改数据算法的区别123456789101112131415161718192021222324252627282930313233343536373839404142431. state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，来显示4. state发生改变5. 数据 + 模板 结合，生成真实的DOM，替换原始DOM* 缺陷： 第一次生成了一个完整的DOM片段 第二次生成了一个完整的DOM片段 第二次的DOM替换第一次的DOM 直接操作DOM元素，消耗大量的性能============================1.state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，并不直接替换原始的DOM4. state 发生改变5. 数据 + 模板 结合，生成真实的DOM，并不直接替换原始DOM6. 新的DOM（DocumentFragment） 和原始的DOM 作比对，找差异7. 找出input 框发生了变化8. 只用新的DOM中的input 元素，替换掉老的DOM的input元素* 缺陷： 性能的提升并不明显，虽然替换input元素节约了一部分性能，但是直接在新旧DOM 做对比，还是有一些性能上的损耗。============================1.state 数据2. JSX 模板3.生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实DOM）(损耗性能)4. 用虚拟DOM的结构，生成真实的DOM，来显示5. state 发生变化6. 数据 + 模板 生成新的虚拟DOM7.比较原始虚拟DOM 和新的虚拟DOM区别，找到两者的区别（极大提升了性能）8.直接操作DOM，改变变化的内容* 优点： 1.性能提升了。 2.它使得跨端应用得以实现 React Native============================ setState优化 setState是异步的，如果连续调用多次setState，react会合并成一次，来节约调用多次setState做的性能消耗。 diff 算法的同层比对 diff算法只比对一层DOM元素，只要一层不一样，则重新生成一次真实DOM，不会继续向下做对比，并替换原来的真实DOM元素，可能会造成DOM重新渲染的浪费，但是因为是同层比对，速度会比较快。而且在虚拟DOM当中设置key值，会对比前后两个虚拟DOM的key值会很快对比出来，当用index来作为key的时候，index是不稳定的，所以尽量不要用index来作为key值，来提升虚拟DOM对比的性能。","categories":[],"tags":[]},{"title":"js里的对象的深浅拷贝","slug":"js深浅拷贝","date":"2018-09-30T06:25:18.000Z","updated":"2018-10-23T02:38:05.827Z","comments":true,"path":"2018/09/30/js深浅拷贝/","link":"","permalink":"https://2rever.cn/2018/09/30/js深浅拷贝/","excerpt":"","text":"众所周知，js里面对象及其数组不是基本数据类型，当复制操作的时候我们不会复制一个值出来，而是复制一个对这个值的指向，当我们有复制对象需求的时候，可以借助lodash上相应的函数，或者使用一下方法实现。 浅拷贝指的是当对象有多层的时候只复制第一层，子对象还是复制的指向。 深拷贝指的是连同子对象都是一个全新的值。 浅拷贝 123456789function shallowCopy(src) &#123; var dst = &#123;&#125; for(var prop in src) &#123; if(src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop] &#125; &#125; return dst&#125; 深拷贝 这种方式是最便捷的深拷贝方式，但是原型链会遭到破坏，原有对象的原型会丢失。 1JSON.parse(JSON.stringify(obj)) 自己实现深拷贝的方式可避免上述的问题 12345678910111213141516171819function deepCopy(src) &#123; // 定义一个对象，用来确定当前的参数是数组还是对象 var objArray = Array.isArray(obj) ? [] : &#123;&#125; // 如果obj存在，且类型为对象 if (obj &amp;&amp; typeof obj === \"object\" ) &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 如果obj的子元素是对象，递归操作 if (obj[key] &amp;&amp; typeof obj[key] === \"object\") &#123; objArray[key] = deepCopy(obj[key]) &#125;else &#123; // 如果不是，直接赋值 objArray[key] = obj[key] &#125; &#125; &#125; &#125; return objArray //返回新的对象&#125;","categories":[],"tags":[]},{"title":"html和css的命名规范","slug":"html、css命名规范","date":"2018-08-19T12:33:58.000Z","updated":"2019-03-18T13:38:45.518Z","comments":true,"path":"2018/08/19/html、css命名规范/","link":"","permalink":"https://2rever.cn/2018/08/19/html、css命名规范/","excerpt":"","text":"html和css的命名规范语义化html标签 语义化html元素不仅有利于代码维护，还利于网页的SEO1234567&lt;header&gt;&lt;/header&gt; //头部&lt;nav&gt;&lt;/nav&gt; //导航&lt;aside&gt;&lt;/aside&gt; //一边&lt;article&gt; //文章 &lt;section&gt;&lt;/section&gt; //部分&lt;/article&gt;&lt;footer&gt;&lt;/footer&gt; //页脚 Css命名规范BEM规范 BEM 是一种基于组件的命名方法，它的基本思想是将用户界面划分成独立的模块，即使是复杂的用户界面，也能让开发过程变得简单、快速。并且可以在一定程度上提高代码的可复用性，而不用纯粹的复制粘贴。 BEM 的意思就模块（Block. 、元素（Element. 、修饰符（Modifier. ，使用这种命名方式可以让 CSS 的类名变得有实际意义且能自我解释，具有更高的开发友好性。 123Block - 模块，名字的单词之间用 `-` 符号连接Element - 元素，模块中的子元素，用 `__` 符号连接Modifier - 修饰符，表示父元素或子元素的其他形态，用 `--` 符号连接 在没用 BEM 之前，我们可能会这样组织 CSS 类名：12345678&lt;!-- S Search Bar 模块 --&gt;&lt;div class=\"search-bar\"&gt; &lt;input class=\"input\"&gt; &lt;!-- / input 输入框 --&gt; &lt;button class=\"btn\"&gt; &lt;!-- / button 搜索按钮 --&gt;&lt;/div&gt;&lt;!-- E Search Bar 模块 --&gt; 上述写法虽然也给 class 赋予了一定的语义，但容易产生样式冲突的情况。 用 BEM 命名重写之后：12345678&lt;!-- S Search Bar 模块 --&gt;&lt;div class=\"search-bar\"&gt; &lt;input class=\"search-form__input\"/&gt; &lt;!-- / input 输入框子元素 --&gt; &lt;button class=\"search-form__button\"&gt;&lt;/button&gt; &lt;!-- / button 搜索按钮子元素 --&gt;&lt;/div&gt;&lt;!-- E Search Bar 模块 --&gt; 这样命名的好处是，模块语义化了，便于后期的维护，而且减少了 CSS 样式的层层嵌套，提升了网页的渲染效率。 通常在开发中使用 BEM 命名方法，会搭配 CSS 的预处理语言，如 SCSS 等。这可以一定程度上解决手写冗长命名的繁琐。12345// 以下是 SCSS 代码.search-bar &#123; &amp;__input &#123; ... &#125; &amp;__button &#123; ... &#125;&#125; 使用凹凸实验室的 改造版BEM规范。 为了进一步简化 CSS 的命名，我们凹凸实验室团队推广的 CSS 命名规范并不严格遵循 BEM 规范，不强制使用两个下划线「_ _ 」来分隔 B 和 E，而 E 和 M 之间也不一定要用两个中划线做分隔「- -」。 12345678910&lt;div class=\"app_market_answer\"&gt; &lt;div class=\"app_market_secheader\"&gt;&lt;/div&gt; &lt;div class=\"app_market_answer_list\"&gt; &lt;div class=\"app_market_answer_item\"&gt; &lt;div class=\"app_market_answer_itop\"&gt;&lt;/div&gt; &lt;div class=\"app_market_answer_imid\"&gt;&lt;/div&gt; &lt;a href=\"javascript:;\" class=\"app_market_answer_ibtn\"&gt;去围观&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 前端布局命名规范 前端布局规范细则 命名规范：基本要求： 文件编码统一使用 UTF-8 编码； 命名时以符合语义为主要参考指标，CSS属性书写规范，采用统一风格及命名方法； 结构清晰，层级关系明朗，以不超过三级为标准； 同一表现形式的样式要求可重复利用，模块组件类的样式要求可整体外部移植； 编写 CSS 的时候，应当避免使用CSS Hack，能不用则不用。 所有页面默认都针对Firefox 等最接近标准的浏览器进行设计，然后使用 IE 特有条件注释功能进行针对性修正。 请使用英文进行命名，尽量避免使用拼音。命名要求具有可读性，尽量避免使用缩写。命名虽然允许数字，但应尽量避免使用数字命名。 命名方法 要求采用统一的命名方法。常用命名方法有： 连写式命名法，如：helloworld 中线命名法，如：hello-world（目前采用此方法的较多，建议采用. 下划线命名法，如：hello_world 骆驼命名法，如：helloWorld 帕斯卡命名法，如：HelloWorld 其他方法。 样式文件命名规范 如：123456789全局的：global.css；主要的：master.css；布局、版面：layout.css；专栏：columns.css；文字：font.css；打印样式：print.css；主题：themes.css；补丁：pacth.css；格式化浏览器：base.css等。 ID及Class命名常用名称1234567891011121314151617181920212223242526272829303132333435页头：header登录条：login-bar标志：logo侧栏：side-bar广告：banner导航：nav子导航：sub-nav菜单：menu子菜单：sub-menu搜索：search滚动：scroll页面主体：main内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guild服务：service热点：hot新闻：news下载：download注册：regsiter状态：status按钮：btn投票：vote合作伙伴：partner友情链接：friendlink版权：copyright外套：wrap页脚：footer标题：title顶导航：top-nav(mini-nav)","categories":[],"tags":[]},{"title":"这是我的第一篇文章","slug":"Hexo博客添加评论功能","date":"2018-08-12T04:02:06.000Z","updated":"2019-03-18T13:38:47.531Z","comments":true,"path":"2018/08/12/Hexo博客添加评论功能/","link":"","permalink":"https://2rever.cn/2018/08/12/Hexo博客添加评论功能/","excerpt":"","text":"Hexo博客添加valine评论功能增加评论功能我原来以为添加评论是一件很麻烦的事情，其实就是在LeanCloud上注册账号，获取appId和appKey，然后在themes目录下自己选用的主题目录下，找到_config.yml文件，找到valine字段，把下文xxx字段替换为valine官网上设置里面获取的值填进去就完了，由于本主题已经集成多种非后端评论系统，所以直接开箱即用。12valine_appId: xxxvaline_appKey: xxx","categories":[],"tags":[]}]}