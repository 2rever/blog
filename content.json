{"meta":{"title":"2rever的前端小站","subtitle":null,"description":null,"author":"2rever","url":"https://2rever.cn"},"pages":[],"posts":[{"title":"react 虚拟DOM和diff算法的笔记","slug":"react 虚拟DOM和diff算法的笔记","date":"2018-10-11T14:57:32.000Z","updated":"2018-10-11T15:04:36.653Z","comments":true,"path":"2018/10/11/react 虚拟DOM和diff算法的笔记/","link":"","permalink":"https://2rever.cn/2018/10/11/react 虚拟DOM和diff算法的笔记/","excerpt":"","text":"react 虚拟DOM和diff算法的笔记几种更改数据算法的区别123456789101112131415161718192021222324252627282930313233343536373839404142431. state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，来显示4. state发生改变5. 数据 + 模板 结合，生成真实的DOM，替换原始DOM* 缺陷： 第一次生成了一个完整的DOM片段 第二次生成了一个完整的DOM片段 第二次的DOM替换第一次的DOM 直接操作DOM元素，消耗大量的性能============================1.state 数据2. JSX 模板3. 数据 + 模板 结合，生成真实DOM，并不直接替换原始的DOM4. state 发生改变5. 数据 + 模板 结合，生成真实的DOM，并不直接替换原始DOM6. 新的DOM（DocumentFragment） 和原始的DOM 作比对，找差异7. 找出input 框发生了变化8. 只用新的DOM中的input 元素，替换掉老的DOM的input元素* 缺陷： 性能的提升并不明显，虽然替换input元素节约了一部分性能，但是直接在新旧DOM 做对比，还是有一些性能上的损耗。============================1.state 数据2. JSX 模板3.生成虚拟DOM（虚拟DOM就是一个JS对象，用来描述真实DOM）(损耗性能)4. 用虚拟DOM的结构，生成真实的DOM，来显示5. state 发生变化6. 数据 + 模板 生成新的虚拟DOM7.比较原始虚拟DOM 和新的虚拟DOM区别，找到两者的区别（极大提升了性能）8.直接操作DOM，改变变化的内容*优点： 1.性能提升了。 2.它使得跨端应用得以实现 React Native============================ setState优化 setState是异步的，如果连续调用多次setState，react会合并成一次，来节约调用多次setState做的性能消耗。 diff 算法的同层比对 diff算法只比对一层DOM元素，只要一层不一样，则重新生成一次真实DOM，不会继续向下做对比，并替换原来的真实DOM元素，可能会造成DOM重新渲染的浪费，但是因为是同层比对，速度会比较快。而且在虚拟DOM当中设置key值，会对比前后两个虚拟DOM的key值会很快对比出来，当用index来作为key的时候，index是不稳定的，所以尽量不要用index来作为key值，来提升虚拟DOM对比的性能。","categories":[],"tags":[]},{"title":"js里的对象的深浅拷贝","slug":"js深浅拷贝","date":"2018-09-30T06:25:18.000Z","updated":"2018-10-10T04:46:20.701Z","comments":true,"path":"2018/09/30/js深浅拷贝/","link":"","permalink":"https://2rever.cn/2018/09/30/js深浅拷贝/","excerpt":"","text":"js里的对象的深浅拷贝js众所周知，js里面对象及其数组不是基本数据类型，当复制操作的时候我们不会复制一个值出来，而是复制一个对这个值的指向，当我们有复制对象需求的时候，可以借助lodash上相应的函数，或者使用一下方法实现。 浅拷贝指的是当对象有多层的时候只复制第一层，子对象还是复制的指向。 深拷贝指的是连同子对象都是一个全新的值。 浅拷贝 123456789function shallowCopy(src) &#123; var dst = &#123;&#125; for(var prop in src) &#123; if(src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop] &#125; &#125; return dst&#125; 深拷贝 这种方式是最便捷的深拷贝方式，但是原型链会遭到破坏，原有对象的原型会丢失。 1JSON.parse(JSON.stringify(obj)) 自己实现深拷贝的方式可避免上述的问题12345678910111213141516171819function deepCopy(src) &#123; // 定义一个对象，用来确定当前的参数是数组还是对象 var objArray = Array.isArray(obj) ? [] : &#123;&#125; // 如果obj存在，且类型为对象 if (obj &amp;&amp; typeof obj === \"object\" ) &#123; for (key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 如果obj的子元素是对象，递归操作 if (obj[key] &amp;&amp; typeof obj[key] === \"object\") &#123; objArray[key] = deepCopy(obj[key]) &#125;else &#123; // 如果不是，直接赋值 objArray[key] = obj[key] &#125; &#125; &#125; &#125; return objArray //返回新的对象&#125;","categories":[],"tags":[]},{"title":"这是我的第一篇文章","slug":"Hexo博客添加评论功能","date":"2018-08-12T04:02:06.000Z","updated":"2018-08-12T04:01:19.228Z","comments":true,"path":"2018/08/12/Hexo博客添加评论功能/","link":"","permalink":"https://2rever.cn/2018/08/12/Hexo博客添加评论功能/","excerpt":"","text":"Hexo博客添加valine评论功能增加评论功能我原来以为添加评论是一件很麻烦的事情，其实就是在LeanCloud上注册账号，获取appId和appKey，然后在themes目录下自己选用的主题目录下，找到_config.yml文件，找到valine字段，把下文xxx字段替换为valine官网上设置里面获取的值填进去就完了，由于本主题已经集成多种非后端评论系统，所以直接开箱即用。12valine_appId: xxxvaline_appKey: xxx","categories":[],"tags":[]}]}